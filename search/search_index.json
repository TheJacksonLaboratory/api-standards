{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"None","text":"<p>  Standards      </p> <p> Fostering Collaboration &amp; Interoperability In Genomic Data Science </p> <p>APIs implementation plays a critical role in creation of scientific software, and thus  scientific discovery. These documents propose a set of standards to both ease use of  scientific software APIs, and ease their creation. By adhering to these standards, we  aim to enhance the interoperability of our systems, improve the quality and  reproducibility of scientific research, and foster an environment of open collaboration among researchers in the genomics and genetics community.</p> <ul> <li> <p> Easy To Use</p> <p>Simple and approachable standards to help make software engineering faster, not  slower.</p> <p>Use your brainspace to work through scientific problems instead of architectural  ones.</p> </li> <li> <p> Defaults, Not Mandates</p> <p>Each problem is different, and the needs a project should always take precedence over strict adherence to a standard.</p> </li> <li> <p> Open Source, Apache License 2.0</p> <p>Open source and available on GitHub.</p> <p> Our License</p> </li> <li> <p> Fully Versioned</p> <p>Standards are released with semantic versioning and preserved for future reference.</p> <p>Currently In Pre-release</p> <p>We're still working on finalizing the first version of these standards.</p> <p>We don't expect any major changes, but we won't be preserving versions until we release the first version.</p> </li> <li> <p> Based On Existing Work</p> <p>These standards collect the hard work of others, so you don't have to.</p> <p>Check out the awesome people we draw influence from:</p> <p> Mozilla</p> <p> IETF</p> <p> Twelve Factor App</p> </li> <li> <p> Made For The Real World</p> <p>Created by the API Standards Group at The Jackson Laboratory,  an open working group that is focused on creating standards for the development of APIs.</p> <p>The goals of this group are to create a set of standards that will allow for the  creation of APIs that are consistent, easy to use, easy to maintain, and which meet the  goals and priorities needed for user-interface development.</p> </li> </ul>"},{"location":"01-http-standards/","title":"1 Methods &amp; Status Codes","text":"<p>Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol used for  communication between web servers and clients, allowing for the transfer of data and  requests for resources over the internet. This document summarizes two important sources of information for HTTP standards:</p> <ul> <li>The Mozilla Developer Network (MDN) HTTP Reference<sup>1</sup></li> <li>The HTTP Semantics RFC (RFC 9110)<sup>2</sup></li> </ul>"},{"location":"01-http-standards/#11-http-methods","title":"1.1 HTTP Methods","text":""},{"location":"01-http-standards/#111-common-implementation-methods","title":"1.1.1 Common Implementation Methods","text":"<p>The following methods are commonly used for the endpoints we create in our web APIs.  They are useful for creating semantically meaningful RestFUL APIs.</p> Method Type Description GET Read Only, Idempotent The GET method requests a representation of the specified resource. Requests using GET should only retrieve data. HEAD Read Only, Idempotent The HEAD method asks for a response identical to a GET request, but without the response body. POST Non-idempotent The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server. PUT Idempotent The PUT method replaces all current representations of the target resource with the request payload. DELETE Idempotent The DELETE method deletes the specified resource. PATCH Non-idempotent The PATCH method applies partial modifications to a resource."},{"location":"01-http-standards/#112-common-operational-methods","title":"1.1.2 Common Operational Methods","text":"<p>These methods are most commonly handled by the web-frameworks/web-server and are not typically used when implementing our own endpoints.</p> Method Description CONNECT The CONNECT method establishes a tunnel to the server identified by the target resource. OPTIONS The OPTIONS method describes the communication options for the target resource. TRACE The TRACE method performs a message loop-back test along the path to the target resource."},{"location":"01-http-standards/#12-http-response-status-codes","title":"1.2 HTTP Response Status Codes","text":"<p>We will list only the most relevant status codes here, but in general, we follow the mozilla guidelines. The  following descriptions are taken directly from the mozilla documentation.</p>"},{"location":"01-http-standards/#121-2xx-success","title":"1.2.1 2xx Success","text":"<p>These codes indicate success. The three most common that we use are listed here, and  have only slight differences. </p> Status Code Description Long Description 200 OK The request succeeded. The result meaning of \"success\" depends on the HTTP method. 201 Created The request succeeded, and a new resource was created as a result. This is typically the response sent after POST requests, or some PUT requests. 204 No Content There is no content to send for this request, but the headers may be useful. The user agent may update its cached headers for this resource with the new ones."},{"location":"01-http-standards/#122-4xx-client-error","title":"1.2.2 4xx Client Error","text":"<p>These codes indicate that the server determined that client did something wrong with the request. These are the most straightforward to implement from a backend perspective, and provide the most information to the client about what went wrong.</p> Status Code Description Long Description 400 Bad Request The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). 401 Unauthorized Although the HTTP standard specifies \"unauthorized\", semantically this response means \"unauthenticated\". That is, the client must authenticate itself to get the requested response. 403 Forbidden The client does not have access rights to the content; that is, it is unauthorized, so the server is refusing to give the requested resource. Unlike 401 Unauthorized, the client's identity is known to the server. 404 Not Found The server cannot find the requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 Forbidden to hide the existence of a resource from an unauthorized client. 405 Method Not Allowed The request method is known by the server but is not supported by the target resource. For example, an API may not allow calling DELETE to remove a resource. 409 Conflict This response is sent when a request conflicts with the current state of the server. 422 Unprocessable Entity The request was well-formed but was unable to be followed due to semantic errors."},{"location":"01-http-standards/#123-5xx-server-error","title":"1.2.3 5xx Server Error","text":"<p>These codes indicate that the server had a problem processing the request. These are the most difficult to implement from a backend perspective, and provide the least information to the client about what went wrong. In general, when using one of these codes, backend APIs should both log the associated error, and provide as much meaningful information as possible to the client.</p> Status Code Description Long Description 500 Internal Server Error Internal Server Error 501 Not Implemented The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are GET and HEAD. 502 Bad Gateway This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response. 504 Gateway Timeout This error response is given when the server is acting as a gateway and cannot get a response in time. <ol> <li> <p>Mozilla: HTTP Status \u21a9</p> </li> <li> <p>RFC 9110 HTTP Semantics \u21a9</p> </li> </ol>"},{"location":"02-domain-names/","title":"2 Domain Names","text":"<p>DNS (Domain Name System) is a system that translates human-friendly domain names, like  <code>www.jax.org</code>, into the numerical IP addresses needed for devices to load Internet  resources. This conversion process is often referred to as DNS name resolution, and it's carried out by DNS servers. DNS serves as a sort of phonebook for the Internet, allowing us to use memorable domain names while computers and other devices can handle the  underlying IP addresses they correspond to.</p> <p>Consistent DNS naming is important to maintaining API standards, both in terms of operations and development. Consistent naming conventions enhance ease of use and  understanding of APIs, as intuitive and uniform naming conventions allow developers to  guess the correct endpoint, thereby reducing reliance on extensive documentation lookup.  Furthermore, DNS naming conventions enhances efficiency in both development and  maintenance as the risk of misconfiguration and mistakes drops when there  are standard conventions to follow in handling APIs. Another aspect is interoperability; standard naming conventions ease integration with other systems and services as they  allow for a common language to be used. Finally, consistency in DNS naming aids in  service discovery, particularly in a microservices architecture in that it streamlines  categorization and comprehension of each service's purpose. </p>"},{"location":"02-domain-names/#21-naming-conventions","title":"2.1 Naming Conventions","text":"<p>There is no single standard for DNS naming conventions that applications are required to follow, however, the following is the default convention that should be followed unless there is a compelling reason to deviate from it.</p> <pre><code>&lt;application_name&gt;-&lt;environment&gt;.&lt;domain&gt;.&lt;tld&gt;\n</code></pre> <p>Where most applications will be hosted on <code>.jax.org</code> <pre><code>&lt;application_name&gt;-&lt;environment&gt;.jax.org\n</code></pre></p>"},{"location":"02-domain-names/#211-production-dns","title":"2.1.1 Production DNS","text":"<p>For production environments, the application will also map a DNS name that does not include the environment name. This is to allow for the use of the shorter DNS name by most end users.</p> <pre><code>&lt;application_name&gt;.&lt;domain&gt;.&lt;tld&gt;\n</code></pre> <p>Where most applications will be hosted on <code>.jax.org</code> <pre><code>&lt;application_name&gt;.jax.org\n</code></pre></p>"},{"location":"02-domain-names/#212-frontend-clients-and-backend-apis","title":"2.1.2 Frontend Clients and Backend APIs","text":"<p>One important consideration is to maintain a list that maps client applications (e.g.,  web apps, CLI tools) to the backend services they employ. This also helps manage CORS  settings, if needed. This also helps to make it clear when specific frontend clients are siblings of specific backend APIs. </p> <p>Where possible, it is preferred that the frontend client uses the same DNS name as the  backend API. This allows for intuitive discovery of the backend API by the frontend  client, and by developers, quality assurance, and operations personnel.</p> <p>Micro-service Architectures</p> <p>In a world of micro-services it's likely that we would move away from a one-to-one mapping between a UI and an API. In theory services will be for specific purposes, while clients may become more broad and integrated, pulling from multiple APIs.</p> <p>Data or analytic API\u2019s should also be concerned with serving up other programmatic clients, like scripts or Jupyter notebooks developed by an analyst.</p>"},{"location":"02-domain-names/#213-versioning","title":"2.1.3 Versioning","text":"<p>Versioning should be handled by the application itself, and not by the DNS name. This allows for the application to be updated to a new version without requiring any changes to the DNS name.</p> <p>Versioning Not Required</p> <p>Not all APIs will require versioning, and those that do not should not feel  compelled to implement it. Often, versioning can be avoided by careful design of the API.</p> <p>Read more about API Versioning in the API Standards group's versioning document.</p>"},{"location":"02-domain-names/#213-environments","title":"2.1.3 Environments","text":"<p>The environment name should be one of the following:</p> <ul> <li><code>dev</code> - Development environment</li> <li><code>sqa</code> - Testing environment</li> <li><code>stage</code> - Staging environment</li> <li><code>prod</code> - Production environment</li> </ul> <p>It is highly recommended to deploy each of the above environments, especially if your application will rely on other applications, or if other applications will rely on your application. This allows for your application, and those that depend on it, to always have a matching environment for each deployment environment.</p>"},{"location":"02-domain-names/#214-stagingproduction","title":"2.1.4 Staging/Production","text":"<p>The staging and production environments are special environments that should be as close to identical as possible. The only difference between the two should be the data that they are using. This is to ensure that any issues that are found in staging can be reproduced in production. </p> <p>Depending on your application deployment model, these two environments can be viewed as the \"Blue\" and \"Green\" in a \"Blue/Green\" deployment model.</p> Blue/Green Deployments <p>Blue/Green deployments are a type of software release management strategy designed to    reduce downtime and risk by running two identical production environments known as    Blue and Green.</p> <ul> <li>Blue environment: This is the live production environment that is currently serving      user traffic.</li> <li>Green environment: This is the clone of the production environment where you deploy      the new version of the application.</li> </ul> <p>Initially, the Blue environment is live, serving all user traffic. When a new version    of the software is ready for release, it is deployed to the Green environment. </p> <p>Once the new version is tested and ready to go live, the router is switched to direct    all incoming traffic to the Green environment. The Green environment then becomes the    live or active environment. </p> <p>The Blue environment, now idle, can be used for preparation for the next release.</p>"},{"location":"02-domain-names/#22-additional-considerations","title":"2.2 Additional Considerations","text":"<p>1) Applications should be hosted on port 80/443 so that the user does not need to  specify a port. 2) It's important to publicize if the application is hosted on an internal-only IP address as this will affect the ability of users to access the application.</p>"},{"location":"03-endpoint-naming/","title":"3 Endpoint Naming","text":"<p>Overview</p> <p>The RESTful API Endpoint Naming Standards are a set of guidelines we follow  to maintain consistency, clarity, and usability in our APIs. </p> <p>Application Programming Interfaces (APIs) act as the gateways to data and capabilities  of our applications. With the REST architectural style, we can create scalable APIs that are easy to consume and understand. </p> <p>Following a set of established naming conventions helps us create APIs that are  straightforward to use, which in turn accelerates development, minimizes the risk of  errors, and makes our services easier to consume.</p> <p>Tip</p> <p>Although these are presented as standards, they should be considered as guidelines.  In specific cases, there might be valid reasons to deviate from these standards.  However, any deviation should be carefully considered and thoroughly discussed  within the team.</p>"},{"location":"03-endpoint-naming/#31-endpoint-naming-principles","title":"3.1 Endpoint Naming Principles","text":"<ul> <li> <p>3.1.1. Resource Identification </p> <p>RESTful APIs use nouns (not verbs) to identify resources or collections of  resources. For example, use <code>/users</code> not <code>/getUsers</code> or <code>/createUser</code>.</p> </li> <li> <p>3.1.2 Consistency </p> <p>Maintain consistent naming conventions across the API. This reduces ambiguity and  increases usability.</p> </li> <li> <p>3.1.3 Plural Form Resources </p> <p>Resources should be named in plural form, such as <code>/users</code> rather than <code>/user</code>.</p> </li> <li> <p>3.1.4 Hierarchical Relationships </p> <p>Use sub-resources to show relationships between resources. For example, to get a  user's comments, you can use <code>/users/{id}/comments</code>.</p> </li> <li> <p>3.1.5 Lowercase Letters </p> <p>Use lowercase letters for resources and collections. Mixed case or camelCase can  lead to confusion and errors.</p> </li> <li> <p>3.1.6 Avoid Underscores (_) </p> <p>Underscores can sometimes be interpreted as spaces in certain contexts and should be avoided. Use hyphens (-) for better readability if needed<sup>2</sup>.</p> </li> <li> <p>3.1.7 No Trailing Slashes </p> <p>Trailing slashes should be avoided. For example, use <code>/users</code> not <code>/users/</code><sup>1</sup>. </p> </li> <li> <p>3.1.8 Non-CRUD Functions </p> <p>For routes that don't easily map to CRUD operations (Create, Read, Update, Delete),  consider mapping these to HTTP methods in a sensible way, or group them under a  sub-resource. For example, <code>/users/{id}/activate</code>.</p> </li> <li> <p>3.1.9 Filters, Sorting, and Pagination </p> <p>For large collections, these should be expressed as query parameters. For example,  <code>/users?status=active&amp;sort=-registered&amp;page=2</code>.</p> </li> <li> <p>3.1.1 HTTP Status Codes </p> <p>Use appropriate HTTP status codes to indicate the status of the request. For  example, '200' for successful GET requests, '201' for successful POST requests, '400'  for bad requests, etc. </p> <p>HTTP Status Codes</p> <p>For more information on the correct status codes to use, see the response  status codes section of the  HTTP Standards page.</p> </li> <li> <p>3.1.1 Error Handling </p> <p>Always return meaningful error messages and codes, helping the consumer understand  what went wrong and how they might fix it.</p> </li> </ul> <p>Warning</p> <p>Remember that these are guidelines, not hard rules. They serve as a starting  point for the API design, but each API has unique needs and may require certain  exceptions or adaptations. Always prioritize clarity, simplicity, and usability  when designing your API.</p>"},{"location":"03-endpoint-naming/#32-when-exceptions-are-required","title":"3.2 When Exceptions are Required","text":"<p>Despite these guiding principles, there may be situations that require exceptions or  deviations. These could include compatibility with legacy systems, specific requirements of certain clients, or other unique constraints.</p> <p>In such cases, exceptions should be carefully considered, thoroughly discussed within  the team, and clearly documented to avoid confusion and ensure everyone understands the  reasons behind the deviation.</p> <p>Always consider the potential impact of any exceptions on the overall usability,  clarity, and consistency of the API, and strive to minimize such deviations as much as  possible.</p> <ol> <li> <p>RFC 3986 - Uniform Resource Identifier (URI): Generic Syntax \u21a9</p> </li> <li> <p>StackOverflow - Hyphens, Underscores, or Camel Case \u21a9</p> </li> </ol>"},{"location":"04-openapi-schemas/","title":"4 OpenAPI Schemas","text":"<p>Overview</p> <p>As part of our commitment to creating well-defined, reliable, and easy-to-use APIs,  we adopt OpenAPI<sup>1</sup> as a standard tool for defining, creating, and documenting our  APIs. OpenAPI helps our teams collaborate more efficiently, enhances the developer  experience, and maintains the quality of our APIs. This document lays out standards  and best practices around the usage and publication of OpenAPI schemas.</p>"},{"location":"04-openapi-schemas/#why-openapi","title":"Why OpenAPI?","text":"<p>OpenAPI<sup>1</sup> is an industry-standard method for describing RESTful APIs. By requiring an  OpenAPI document<sup>2</sup> for each API, we aim to:</p> <ul> <li> <p>Increase Transparency </p> <p>With an OpenAPI document, every aspect of an API is clearly described, from endpoints to response formats. This reduces guesswork and the potential  for misunderstandings.</p> </li> <li> <p>Streamline Collaboration </p> <p>Frontend and backend teams can reference the OpenAPI  document to understand what data is available, how to access it, and what kind of  responses to expect. </p> </li> <li> <p>Simplify Integration </p> <p>Other systems or third-party developers can use the OpenAPI  document to understand how to integrate with our APIs. </p> </li> <li> <p>Enable API Testing and Monitoring </p> <p>OpenAPI documents can be used to generate  testing scripts and monitor APIs for any discrepancies in expected behavior.</p> </li> <li> <p>Improve Developer Experience </p> <p>An OpenAPI document forms the basis for generating  interactive documentation, SDKs, and API explorers, enhancing the overall developer  experience.</p> </li> </ul>"},{"location":"04-openapi-schemas/#key-principles","title":"Key Principles","text":"<ol> <li> <p>Up-to-date Schema </p> <p>Each RESTful API must always provide an up-to-date  <code>openapi.json</code> file, reflecting the latest version of the API. </p> </li> <li> <p>Automatic Generation </p> <p>The <code>openapi.json</code> file should be automatically generated  from the source code and annotations as part of the build pipeline.</p> </li> <li> <p>Public Accessibility </p> <p>The <code>openapi.json</code> file should be easily accessible through a dedicated endpoint.</p> <ul> <li>(3.a) The openapi.json file will be available at the root of your API.</li> </ul> </li> <li> <p>Auto-generated API Documentation </p> <p>The OpenAPI schema should be used to  automatically generate and update API navigator pages or interactive API documentation  (like Swagger UI).</p> </li> <li> <p>Schema Definitions </p> <p>Schema definitions should always be as specific as  possible. Generic schema usage (like <code>object</code>) should be avoided.</p> </li> <li> <p>Direct Object Return </p> <p>All endpoints returning object structures provide these  objects directly in the response body without wrapping them in additional container  objects. This approach minimizes unnecessary parsing and improves the direct usability  of our API responses.</p> </li> </ol>"},{"location":"04-openapi-schemas/#detailed-standards","title":"Detailed Standards","text":""},{"location":"04-openapi-schemas/#41-openapi-file-generation","title":"4.1 OpenAPI File Generation","text":"<ul> <li> <p>4.1.1 </p> <p>Use tools and libraries that support OpenAPI file generation from code annotations  (e.g., Swagger for Java or SpringFox). </p> </li> <li> <p>4.1.2 </p> <p>The OpenAPI file should be generated as part of the build process. </p> </li> <li> <p>4.1.3 </p> <p>Keep your annotations up-to-date as you make changes to your API.</p> </li> </ul>"},{"location":"04-openapi-schemas/#42-openapi-file-hosting","title":"4.2 OpenAPI File Hosting","text":"<ul> <li> <p>4.2.1 </p> <p>The <code>openapi.json</code> file should be publicly accessible via a dedicated URL.</p> </li> <li> <p>4.2.2 </p> <p>The file should be placed at a consistent location across all APIs for easy discovery    (e.g., <code>https://myapp.jax.com/openapi.json</code>).</p> </li> <li> <p>4.2.3 </p> <p>The server should deliver the <code>openapi.json</code> file with the correct MIME type  <code>application/json</code>.</p> </li> <li> <p>4.2.4 </p> <p>The openapi.json file will be available at the root of your API. For    example, if <code>myapp.jax.org/api</code> is the root of your API, the openapi.json file will   be available at <code>myapp.jax.org/api/openapi.json</code> </p> </li> </ul>"},{"location":"04-openapi-schemas/#43-versioning","title":"4.3 Versioning","text":"<ul> <li> <p>4.3.1 </p> <p>The OpenAPI document should reflect the current version of the API and be updated with each version change.</p> </li> <li> <p>4.3.2 </p> <p>If multiple versions of the API exist, each version should have its own <code>openapi.json</code> file.</p> </li> </ul>"},{"location":"04-openapi-schemas/#44-schema-definitions","title":"4.4 Schema Definitions","text":"<ul> <li> <p>4.4.1 </p> <p>Schema definitions should always be as specific as possible.</p> </li> <li> <p>4.4.2 </p> <p>Edpoints that return an object must define that object as a schema that matches  the structure of the object to be returned.</p> </li> <li> <p>4.4.3 </p> <p>The generic <code>object</code>(<code>{}</code>) schema should not be used unless the structure of response  object is not known until runtime.</p> </li> </ul>"},{"location":"04-openapi-schemas/#45-direct-object-return","title":"4.5 Direct Object Return","text":"<ul> <li> <p>4.5.1 </p> <p>When an endpoint returns an object, the response should directly contain the object's  properties without nesting it within an outer container schema. </p> </li> <li> <p>4.5.2 </p> <p>When an endpoint returns a collection of objects, the response should directly return a list of those objects, without nesting it within an outer container schema</p> </li> </ul> Compliant Example <pre><code>{\n  \"some_key\": \"some_value\"\n}\n</code></pre> <pre><code>[\n    {\n        \"some_key\": \"some_value\"\n    },\n    {\n        \"some_other_key\": \"some_other_value\"\n    }\n]\n</code></pre> Non-Compliant Example <pre><code>{\n  \"mything\": {\n    \"some_key\": \"some_value\"\n  }\n}\n</code></pre>"},{"location":"04-openapi-schemas/#46-auto-generated-api-documentation","title":"4.6 Auto-generated API Documentation","text":"<ul> <li> <p>4.6.1 </p> <p>Use a tool like Swagger UI or ReDoc to automatically generate interactive API  documentation from the OpenAPI schema.</p> </li> <li> <p>4.6.2 </p> <p>The documentation should be publicly accessible and updated automatically whenever the  OpenAPI schema is updated.</p> </li> <li> <p>4.6.3 </p> <p>The documentation should provide interactive features such as the ability to send test requests.</p> </li> </ul> <p>Info</p> <p>By adopting OpenAPI and following these standards and best practices, we can improve  the developer experience, enhance the discoverability of our APIs, and ensure our  documentation is always up-to-date.</p> <ol> <li> <p>OpenAPI Initiative \u21a9\u21a9</p> </li> <li> <p>OpenAPI Specification \u21a9</p> </li> </ol>"},{"location":"05-api-versioning/","title":"5  API Versioning and Backwards Compatibility","text":"<p>Overview</p> <p>In order to prioritize simplicity, reliability, and maintainability we seek to  minimize the need for API versioning as much as possible.</p> <p>API versioning is a strategy to ensure that changes to the structure,  features, or behavior of an API (Application Programming Interface) do not break  applications that depend on it. APIs allow different software applications to  communicate and interact with each other, so changes to an API can have broad impacts.</p> <p>Tip</p> <p>If your service has a single client, which you control, then you can avoid versioning altogether. You also do not need to version APIs which have not yet been released. </p> <p>Warning</p> <p>This document talks about versioning API deployments, a process that is separate  from application release versioning, which is described in the  Software Versions Document.</p> <p>In the context of application release versioning, this document describes the  process of incrementing the major version number. For example, going from <code>v1.0.0</code> to <code>v2.0.0</code>.</p>"},{"location":"05-api-versioning/#51-guiding-principles","title":"5.1 Guiding Principles","text":"<ul> <li> <p>5.1.1. Minimal versioning </p> <p>Avoid versioning unless absolutely necessary. This approach reduces complexity, both for the team developing the API and for those who consume it. We strive, whenever possible, to make changes that are backwards compatible.</p> </li> <li> <p>5.1.2 Independent changes for reproducible science </p> <p>To support reproducible science, it's essential that we can modify APIs without  impacting the analysis. This principle allows us to evolve our systems independently,  providing robustness and flexibility.</p> </li> </ul> <p>When versioning becomes unavoidable due to changes that can break existing clients, we should follow the strategies provided in this guide.</p> <p>Danger</p> <p>Versioning is not a substitute for good API design. We should always strive to design APIs that are flexible and extensible, and that can evolve without breaking existing integrations. Incrementing a major version should be a last resort.</p>"},{"location":"05-api-versioning/#52-backwards-compatibility","title":"5.2 Backwards Compatibility","text":"<p>Backwards compatibility is as important as versioning. By maintaining backwards compatibility, we allow API consumers to upgrade at their own pace without breaking their existing integrations. Strategies to ensure backwards compatibility include:</p> <ul> <li> <p>5.2.1 Adding new fields</p> <p>When adding new data, do so by adding new fields that older    clients will simply ignore. The simplest way to do this is to add new fields that     have a default value. </p> </li> <li> <p>5.2.2 Avoid removing fields</p> <p>Removing data fields may break existing integrations. It's    safer to deprecate old fields and leave them in place, while encouraging clients to    use new fields.</p> </li> <li> <p>5.2.3 Keeping old endpoints</p> <p>If creating a new version of an endpoint, consider keeping    the old one for a time to allow clients to transition gradually.</p> </li> <li> <p>5.2.4 Communicating changes</p> <p>Whenever a change is made that affects the API, it's    important to inform consumers in advance to give them time to adapt.</p> </li> </ul>"},{"location":"05-api-versioning/#service-information-endpoint","title":"Service Information Endpoint","text":"<p>A service information endpoint is a valuable tool in API design, especially in terms of API versioning and backwards compatibility. The service information endpoint provides a clear way for client applications to understand the current state of the service, its capabilities, and its versioning details. This enables clients to interact more intelligently and efficiently with the service, adjusting their behavior based on the information returned by this endpoint.</p> <p>Here's how a service information endpoint contributes to API versioning and backward compatibility:</p> <ul> <li>5.3.1 Communicating Version Information:</li> </ul> <p>The version of the API is often part of the service information. This makes it clear    to any consumers of the API what version they are interfacing with. Consumers can    then decide how to handle any changes based on the version information. This is where    an application would provide its deployed    Software Version number.</p> <ul> <li>5.3.2 Facilitating Backward Compatibility:</li> </ul> <p>By communicating what features, workflows, and filesystem protocols are supported by    the service, a client application can adjust its behavior to only use features    supported by the current API version. This allows older clients to still function    correctly, even if new features or changes have been introduced in the latest version    of the API.</p> <ul> <li>5.3.3 Providing Useful Metadata:</li> </ul> <p>Additional information such as the name, description, environment, and contact    details helps clients understand more about the service. For instance, it can help    debug issues (e.g., if the environment is \"test\", the behavior might be different    from a production environment).</p> <ul> <li>5.3.4 Allowing Intelligent Client Behavior:</li> </ul> <p>In a more advanced use case, a client application might use the service information    to decide between different APIs or services. </p>"},{"location":"05-api-versioning/#when-we-need-to-version","title":"When We Need to Version","text":"<p>Despite our minimal versioning philosophy, there may be situations that require it. These could include major architectural changes, the addition of new features that aren't compatible with the current API design, or the nature of the system that's being changed. </p> <p>In these cases, we should follow the versioning strategies outlined below.</p>"},{"location":"05-api-versioning/#versioning-strategies","title":"Versioning Strategies","text":"<p>When we need to introduce versioning, you might consider adopting one of the following strategies:</p> <ul> <li> <p>5.4.1 URI Versioning</p> <p>In this strategy, the version information is included in the URI    itself. This is very simple and straightforward, but it can break URI consistency and    may cause confusion.</p> <ul> <li> <p>5.4.1.1 URI Path</p> <p>This option involves including the version number as part of  the URI path. This allows clients to cache resources easily, but requires   branching the entire API when incrementing the version.</p> </li> <li> <p>5.4.1.2 Query Parameters</p> <p>This option involves including the version number as a  query parameter. This is straightforward to implement, but can become   difficult to manage across multiple endpoints. It also requires maintaining  all versions of the endpoints in a single application build.</p> </li> </ul> </li> <li> <p>5.4.2 Request Header Versioning</p> <p>This approach keeps the URI clean and includes the    version information in the request header. This preserves URI consistency, but it    requires consumers to add version information to their requests.</p> </li> <li> <p>5.4.3 Media Type Versioning (Accept Header)</p> <p>This strategy requires the client to    specify the version in the Accept header. It offers clean URIs, but it may increase    complexity for clients.</p> </li> <li> <p>5.4.4 Hypermedia As The Engine Of Application State (HATEOAS)</p> <p>This is the most complex    strategy, but it provides a lot of flexibility. It allows API consumers to navigate    APIs through hypermedia links.</p> </li> </ul> <p>Remember, the choice of versioning strategy should be informed by our guiding principles, the needs of our API consumers, and the nature of the changes that require versioning. You should pick the strategy that best fits the situation of your  application and it's needs, and prioritize minimizing API versioning as much as  possible.</p> <p>Tip</p> <p>For more information on possible versioning strategies, see this guide.</p>"},{"location":"06-api-monitoring/","title":"6 API Monitoring","text":"<p>These guiding principles will help stability, uptime, and awareness for your applications.</p> <p>Actuator endpoints let you monitor and interact with your application. </p>"},{"location":"06-api-monitoring/#61-monitoring","title":"6.1 Monitoring","text":"<ul> <li> <p>6.1.1 Endpoints for monitoring and info will exist at:</p> <pre><code>/api/monitor/&lt;resource&gt;/&lt;type&gt;\n</code></pre> </li> </ul>"},{"location":"06-api-monitoring/#62-health-endpoint","title":"6.2 Health Endpoint","text":"<p>Required</p> <p>This endpoint is required for all applications.</p> <ul> <li> <p>6.2.1 This endpoint provides health information, mainly the status of the  application. It will be the primary target for monitoring services.</p> <p>Location: <pre><code>http://127.0.0.1/api/monitor/server/health\n</code></pre></p> </li> </ul> <p>Example Response: <pre><code>{\"name\":\"Fancy Application\",\"status\":\"UP\",\"details\":\"Everything seems okay.\"}\n</code></pre></p> Status Text Http Status Code <code>UP</code> 200 <code>UNKNOWN</code> 200 <code>DOWN</code> 503"},{"location":"07-error-handling/","title":"7 REST API Error Handling Best Practices","text":"<p>Error handling is crucial for ensuring the reliability and usability of a REST API service. Proper error handling not only helps developers identify and fix issues but also provides clear and informative responses to clients so they may take corrective action.</p>"},{"location":"07-error-handling/#guidelines","title":"Guidelines","text":""},{"location":"07-error-handling/#71-use-appropriate-http-status-codes","title":"7.1 Use Appropriate HTTP Status Codes","text":"<p>HTTP status codes are essential for conveying the outcome of API requests and allow a high level grouping of error responses. Use them consistently to indicate the result of each API call, and avoid using obscure codes that API consumers may not be familiar with.  Common, widely used error codes provide clear semantics and promote consistency and interoperability. These include:  </p> <ul> <li>400 Bad Request: Malformed request syntax or invalid parameters  </li> <li>401 Unauthorized: Authentication required or invalid credentials  </li> <li>403 Forbidden: The authenticated user does not have permission to perform the operation  </li> <li>404 Not Found: Requested resource does not exist</li> <li>422 Unprocessable Content: The request is formed correctly but there are semantical errors in the payload</li> <li>500 Internal Server Error: Generic server-side error</li> </ul>"},{"location":"07-error-handling/#72-provide-detailed-error-messages","title":"7.2 Provide Detailed Error Messages","text":"<p>When an error occurs, include detailed error messages in the response. These messages should provide enough information for consumers to understand the cause of the error and take appropriate actions. However, be cautious not to expose sensitive information or specifics that could be exploited by malicious users.  For example, do not include implementation details or detailed stack traces. Error messages should clarify the problem and communicate the intended functionality. For example, if a type check fails on an API to fetch a study record by id, the message \"Study ID must be an integer\" clearly conveys what is expected.</p>"},{"location":"07-error-handling/#73-implement-consistent-error-response-format","title":"7.3 Implement Consistent Error Response Format","text":"<p>Follow a consistent error response format across all API endpoints, and format error response payloads as JSON. This makes it easier for clients to parse error responses and handle them gracefully. Include fields status, request_id, error_code, message, timestamp, and trace_id in your error responses.</p> <pre><code>{  \n    \"status\": \"\",               HTTP Status Code for the entire request\n    \"request_id\": \"\",           Request identifier generated by the API service\n    \"errors\": [{          \n          \"error_code\": \"\",     Error code (see below)     \n          \"message\": \"\",        Human readable error details\n          \"timestamp\": \"\",      Date/time of the error\n          \"trace_id\": \"\"        Pointer to the log trace\n     }]\n}\n</code></pre>"},{"location":"07-error-handling/#74-return-an-errors-array","title":"7.4 Return An Errors Array","text":"<p>It is possible for multiple errors to occur within one transaction, so for consistency return an errors collection even if there is only one error. </p>"},{"location":"07-error-handling/#75-log-errors-for-debugging","title":"7.5 Log Errors for Debugging","text":"<p>Log errors on the server-side to aid in debugging and monitoring. Include relevant details like error message, error code, request URL, source, user ID (if available), stack trace, and timestamp. Log errors at appropriate severity levels based on the error's impact, for example \"Critical\", \"Error\", \"Warning\", \"Info\", \"Debug\".  If you would like to learn about BioConnect's logging service, please reference the documentation here.</p>"},{"location":"07-error-handling/#76-error-codes","title":"7.6 Error Codes","text":"<p>Use meaningful error codes in addition to HTTP status codes to provide more specific information. CS is developing a standard list of error codes that may be used across all of our software applications, providing the following benefits: 7.6.1 Clarity and specificity: HTTP status codes are useful but can be generic and lack context.  In addition to providing status codes, error codes allow us to convey more detailed information about the nature of the error. 7.6.2 Consistency: By aligning on a standard list of error codes, we can ensure that error responses are uniform and predictable, which will make it easier for front end developers to handle errors and provide consistent messaging to users. 7.6.3 Error reporting and troubleshooting: If errors are properly logged, developers will be able to aggregate log data based on error codes, providing insight into errors that occur most frequently.</p> <p>The following examples show error codes, in combination with status codes and error messages: 1. invalid parameter</p> <pre><code>{  \n    \"status\": \"400\",\n    \"request_id\": \"37472a48-a34e-4813-b064-f863170f33fc\",\n    \"errors\": {\n          \"error_code\": \"parameter_invalid\",  \n          \"message\": \"Cannot convert 'abc' to integer\",  \n          \"timestamp\": \"2023-07-02T14:07:01\",\n          \"trace_id\": \"fb3a02ac6caa\"\n     }  \n}\n</code></pre> <ol> <li>value too large for column in database</li> </ol> <pre><code>{  \n    \"status\": \"400\",\n    \"request_id\": \"a83e5e07-06b2-44f9-a18a-8eefdc3f9bf8\",\n     \"error\": {\n          \"error_code\": \"value_invalid\",  \n          \"message\": \"animal name must be 50 characters or less\",\n          \"timestamp\": \"2023-08-24T01:10:00\",\n          \"trace_id\": \"3ff84c1df586\"\n\n     }  \n}\n</code></pre> <p>Below is the current working list of error codes for CS Rest APIs:</p> <p>400-Bad Request</p> <ul> <li>parameter_missing</li> <li>parameter_invalid</li> <li>parameter_length_exceeded</li> <li>header_invalid</li> </ul> <p>401-Unauthorized</p> <ul> <li>api_key_required</li> <li>api_key_invalid</li> <li>credentials_required</li> <li>credentials_invalid</li> </ul> <p>403-Forbidden</p> <ul> <li>privileges_insufficient</li> <li>request_limit_exceeded</li> </ul> <p>404-Not found</p> <ul> <li>url_invalid</li> </ul> <p>408-Timeout exceeded</p> <ul> <li>timeout_exceeded</li> </ul> <p>422-Unprocessable content</p> <ul> <li>value_missing</li> <li>value_invalid</li> <li>value_length_exceeded</li> </ul>"},{"location":"07-error-handling/#use-cases-examples","title":"Use Cases &amp; Examples","text":"<p>Missing/Invalid Parameters Consider an API that returns a list of animals based on a weight min and max value. A validation check is performed to ensure that both parameters are present and numeric. If the min value type check validation fails, a status code of 400 is returned, along with a \"parameter_invalid\" error code and the message \"min value must be numeric\". If the parameter is missing all together, the following response is issued:</p> <p><pre><code>        min = request.query_params.get('min_value', None)\n        if min is None:\n            return Response(\n              {\n                \"status\": \"400\",\n                \"request_id\": \"7abfde24-b2e8-49f9-af5b-5f45bd56cce3\",\n                \"errors\":[\n                  {\n                    \"error\": {\n                      \"error_code\": \"parameter_missing\",  \n                      \"message\": \"Minimum weight value is required\",\n                      \"timestamp\": \"2023-09-24T01:10:00\",\n                      \"trace_id\": \"48785f565a27\"\n                    }\n                  }\n                ]\n              }\n            )\n</code></pre> This example is a good use case for aggregating and reporting on error data in order to improve user experience.  If your error logs are showing high numbers of \"parameter_invalid\" codes for a certain API, perhaps you should look into front end validation and constraints in order to prevent them.</p> <p>Insufficient Privileges It is important to remember that errors involving privileges fall under the 403 status code rather than 401. In the case of user based actions, a 401 status code essentially means \"I don't recognize you\" and 403 means \"I know who you are but you're not allowed to do this.\"</p> <p>A typical use case involving insufficient privileges is an attempt to update a record when the user does not have read/write access to the data. The API logic should perform an authorization check before an attempt to update the record, and if not authorized, the response should inform the user that their request has been denied due to insufficient privileges.</p> <pre><code>return Response(\n  {\n    \"status\": \"403\",\n    \"request_id\": \"5bbca962-1f57-4016-bac5-5ae9a28d7d2e\",\n    \"errors\":[\n      {\n        \"error_code\": \"privileges_insufficient\",  \n        \"message\": \"You do not have sufficient privileges to update this record\",\n        \"timestamp\": \"2023-09-24T01:10:00\",\n        \"trace_id\": \"48785f565a27\"\n      }\n    ]\n  }\n)\n</code></pre> <p>Not all 403 errors are tied to authenticated users</p> <p>They could also be used for anonymous actions that can only be performed under certain circumstances (e.g. time based restrictions.)  Another example is a server that only accepts requests from a predefined range of IP addresses.</p> <p>Database Errors Database errors can be due to authentication/authorization issues, lost connection, or data integrity issues such as constraint violations. Database libraries often have some built in error handling that can be leveraged. When possible, you should catch and handle specific exceptions rather than generic \"Exception\" handlers. Wrap database operations in try-except blocks to catch and handle exceptions, for example:</p> <pre><code>        try:\n            study= Study.objects.get(pk=study_id)\n            return Response({'identifier': study.identifier})\n        except Item.DoesNotExist:\n            return Response(\n               {\n                  \"status\": \"404\",\n                  \"request_id\": \"5bbca962-1f57-4016-bac5-5ae9a28d7d2e\",\n                  \"errors\":[\n                    {\n                      ...\n                    }\n                  ]\n                }\n            )\n</code></pre> <p>APIs should be idempotent</p> <p>There is no way to group requests together in a transaction in REST APIs. To compensate for this, you should endeavor to make your APIs idempotent. With the  exception of a POST request, sending the same request multiple times should produce the  same result. To validate idempotency, implement test cases encompassing multiple  invocations of the same request to ensure consistent outcomes irrespective of the number of executions.</p> <p>Timeout Timeout errors can occur when there are network or service issues, or if a call to the API involves too much data. A retry mechanism may be used to handle timeout errors, although this would normally be handled in front end client code when a 504 (Gateway timeout) is received. If timeouts are occurring due to high server load, consider load balancing and scaling your application to ameliorate them. Also consider monitoring and alerts to notify you when timeouts become frequent.</p> <p>Errors from 3rd Party Libraries When calling methods in a 3rd party library, you can follow best practices for handling specific errors provided you have visibility into the exceptions it may raise. Consider handling these errors with graceful degradation if it's possible for your application to continue to function when they occur, for example if you can't retrieve data use cached data as a fallback. If it's a 3rd party service, and it's possible for it to be down, consider implementing a retry mechanism.</p> <p>An API end point that makes a failed call to a 3rd party service should return a 200 response if the error was isolated to the 3rd party service.</p> <p>Business Logic Failures If a request includes data that fails a back end business logic check, return a status code of 422 (Unprocessable Entity.)  This indicates that the syntax is correct but the value(s) prevented the call from being successfully processed. Include data in the response indicating the specific failure. For example, and end point that creates an animal record expects a date of birth but the date provided is in the future and fails a business rule check. A \"value_invalid\" error code and message stating \"Date of birth cannot be in the future\" allows the client to correct the error.</p>"},{"location":"quick-start/","title":"Quick start","text":""},{"location":"quick-start/#step-1-http","title":"Step 1: HTTP","text":"<p>Follow HTTP Standards</p> <p>HTTP (HyperText Transfer Protocol) is the foundation of data communication for the web, and it is essential to adhere to established standards and practices for building robust web applications. Learn more about HTTP status codes and semantics from these resources:</p> <ul> <li> <p> Mozilla: HTTP Status</p> </li> <li> <p> RFC 9110 HTTP Semantics</p> </li> </ul>"},{"location":"quick-start/#step-2-domain-names","title":"Step 2: Domain Names","text":"<p>Use Consistent Domain Names</p> <p>Consistency in domain names is crucial for maintaining a clear and professional web presence. Ensure that your domain names are easy to remember, reflect your brand, and are consistent across different environments (development, staging, production).</p>"},{"location":"quick-start/#step-3-endpoint-names","title":"Step 3: Endpoint Names","text":"<p>Follow Endpoint Naming Conventions</p> <p>Endpoint naming conventions help ensure that your API is intuitive and predictable. This includes using consistent naming patterns, verb-noun combinations, and reflecting the hierarchy in the endpoint paths.</p>"},{"location":"quick-start/#step-4-openapi","title":"Step 4: OpenAPI","text":"<p>Use OpenAPI Schemas</p> <p>Utilizing OpenAPI allows for standardized documentation, which can be easily understood and used by developers. It helps in defining RESTful interfaces and ensuring that the API meets the needs of various clients by being adaptable and scalable.</p>"},{"location":"quick-start/#step-5-versioning","title":"Step 5: Versioning","text":"<p>Follow Versioning Best Practices</p> <p>API versioning is critical to avoid breaking changes for the clients as your API evolves. Version your API from the beginning, using URL path, query string, or headers to specify the version. Document changes meticulously for each version.</p>"},{"location":"quick-start/#step-6-monitoring-and-health-checks","title":"Step 6: Monitoring and Health Checks","text":"<p>Implement API monitoring and heath endpoints.</p> <p>Effective monitoring and implementing health check endpoints are key to maintaining high availability and performance. These practices help in proactive issue resolution and ensure smooth operation of your services.</p>"},{"location":"quick-start/#step-7-errors","title":"Step 7: Errors","text":"<p>Be predictable when things go wrong.</p> <p>When errors occur, your API should handle them gracefully, providing meaningful error messages and standard HTTP status codes. This helps clients to understand what went wrong and how to potentially rectify the issue.</p>"}]}